# Scalable E-commerce Backend (Microservices)

A scalable e-commerce platform built with microservices architecture. The platform provides comprehensive e-commerce functionality including user management, product catalog, shopping cart, order processing, payments, and notifications.

## Architecture Overview

```mermaid
graph TD
    Client --> Gateway[API Gateway/Nginx]
    Gateway --> UserService[User Service]
    Gateway --> ProductService[Product Service]
    Gateway --> CartService[Shopping Cart Service]
    Gateway --> OrderService[Order Service]
    Gateway --> PaymentService[Payment Service]
    Gateway --> NotificationService[Notification Service]
    
    PaymentService --> Stripe[Stripe API]
    NotificationService --> Email[NodeMailer]
    NotificationService --> SMS[Twilio]
    
    Monitoring[Prometheus/Grafana] --> Gateway
    Logging[ELK Stack] --> Gateway
```

## Features

### Core Services
- **User Service**: Authentication, authorization, profile management
- **Product Service**: Catalog management, inventory, search
- **Shopping Cart Service**: Cart management, session handling
- **Order Service**: Order processing, status tracking
- **Payment Service**: Secure payment processing via Stripe
- **Notification Service**: Email/SMS notifications via NodeMailer/Twilio

### Infrastructure
- **API Gateway**: Request routing and load balancing
- **Monitoring**: Real-time metrics and alerting
- **Logging**: Centralized logging with full-text search
- **Containerization**: Docker-based deployment
- **CI/CD**: Automated testing and deployment

## Tech Stack

### Backend
- Node.js/Express.js
- MongoDB with Mongoose ODM
- JWT for authentication
- bcrypt for password hashing

### Infrastructure
- Docker & Docker Compose
- Nginx (API Gateway/Load Balancer)
- Stripe API

### Monitoring & Logging
- Prometheus & Grafana
- ELK Stack (Elasticsearch, Logstash, Kibana)

## Getting Started

### Prerequisites
- Docker Engine 24.0+
- Docker Compose 2.20+
- Node.js 18+ (for local development)
- MongoDB 6.0+ (for local development)

### Environment Setup

1. Clone the repository:
```bash
git clone https://github.com/yourusername/ecommerce-backend.git
cd ecommerce-backend
```

2. Create environment files:
```bash
# Create .env files for each service
cp .env.example services/user/.env
cp .env.example services/product/.env
cp .env.example services/cart/.env
cp .env.example services/order/.env
cp .env.example services/payment/.env
cp .env.example services/notification/.env
```

3. Configure environment variables:

Required variables for each service:

```plaintext
# User Service (.env)
MONGODB_URI=mongodb://mongodb:27017/users
JWT_SECRET=your_jwt_secret

# Product Service (.env)
MONGODB_URI=mongodb://mongodb:27017/products

# Payment Service (.env)
STRIPE_SECRET_KEY=your_stripe_secret_key
MONGODB_URI=mongodb://mongodb:27017/payment

# Notification Service (.env)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASS=your_app_specific_password
TWILIO_ACCOUNT_SID=your_twilio_sid
TWILIO_AUTH_TOKEN=your_twilio_token
TWILIO_PHONE_NUMBER=your_twilio_number
```

### Running the Application

#### Docker Deployment
```bash
# Start core services
docker compose up -d

# Start monitoring stack
cd monitoring
docker compose up -d
```

### Service Endpoints

| Service | Internal Port | External Port | Endpoint |
|---------|--------------|---------------|-----------|
| API Gateway | 80 | 8080 | http://localhost:8080 |
| User Service | 4000 | - | /v1/api/users/* |
| Product Service | 4001 | - | /v1/api/products/* |
| Cart Service | 4002 | - | /v1/api/cart/* |
| Payment Service | 4003 | - | /v1/api/payments/* |
| Order Service | 4004 | - | /v1/api/orders/* |
| Notification Service | 4005 | - | /v1/api/notification/* |
| Grafana | 3000 | 3000 | http://localhost:3000 |
| Kibana | 5601 | 5601 | http://localhost:5601 |

## Monitoring & Observability

### Grafana Dashboards
- Access: http://localhost:3000
- Default credentials: admin/admin

### Logging (ELK Stack)
- Kibana: http://localhost:5601



## Contributing

1. Fork the repository
2. Create your feature branch: `git checkout -b feature/amazing-feature`
3. Commit your changes: `git commit -m 'Add amazing feature'`
4. Push to the branch: `git push origin feature/amazing-feature`
5. Open a pull request

## Future Plans

- Kubernetes deployment support
- Message queue integration
- Enhanced analytics